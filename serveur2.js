const express = require('express');
const bodyParser = require('body-parser');
const cookieParser = require('cookie-parser');
const mysql = require('mysql');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');
const cors = require('cors');
const { body, validationResult } = require('express-validator');

const Modbus = require('jsmodbus');
const net = require('net');

const MODBUS_SERVER_IP = '192.168.64.149'; // Remplace par l'IP correcte
const MODBUS_PORT = 502;  // Port Modbus standard
const MODBUS_ID = 1;  // ID de l'esclave Modbus (souvent 1 par d√©faut)

// Cr√©er un socket pour la connexion Modbus
const socket = new net.Socket();

// Cr√©er le client Modbus
const client = new Modbus.client.TCP(socket, MODBUS_ID);

const app = express();
const PORT = 3000;
const SECRET_KEY = 'votre-cle-secrete';

// Activer CORS avec la configuration correcte
app.use(cors({
    origin: 'http://192.168.65.227:3001',  // Autoriser l'origine du front-end
    credentials: true,  // Permettre l'envoi de cookies et de headers d'authentification
}));

// Autres middlewares
app.use(bodyParser.json());
app.use(cookieParser());

// Middleware pour logger toutes les requ√™tes
app.use((req, res, next) => {
    console.log(`[${new Date().toISOString()}] ${req.method} ${req.url}`);
    console.log('Corps de la requ√™te:', req.body);
    next();
});

// Se connecter au serveur Modbus
socket.connect(MODBUS_PORT, MODBUS_SERVER_IP, () => {
    console.log(' Connexion au serveur Modbus r√©ussie');
});

// Configuration de la base de donn√©es
const db = mysql.createConnection({
    host: '192.168.65.227',
    user: 'chef',
    password: 'Root@2025',
    database: 'vmc1',
});

// Connexion √† la base
db.connect(err => {
    if (err) {
        console.error('Erreur de connexion √† la base de donn√©es :', err);
        process.exit(1);
    }
    console.log('Connect√© √† la base de donn√©es MySQL.');
});


// Route pour enregistrer un utilisateur et token
app.post('/api/register', [
    body('login')
        .isString()
        .isLength({ min: 3 }).withMessage('Le login doit contenir au moins 3 caract√®res.')
        .trim()
        .escape(),
    body('password')
        .isString()
        .isLength({ min: 6 }).withMessage('Le mot de passe doit contenir au moins 6 caract√®res.'),
    body('role').optional().isString()
], async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        return res.status(400).json({ message: 'Donn√©es invalides', errors: errors.array() });
    }

    const { login, password, role } = req.body;
    console.log(`Demande d'inscription re√ßue pour: ${login}`);

    // V√©rifier si l'utilisateur existe d√©j√†
    db.query('SELECT * FROM Utilisateur WHERE nom = ?', [login], async (err, results) => {
        if (err) {
            console.error('Erreur lors de la v√©rification de l\'utilisateur :', err);
            return res.status(500).json({ message: 'Erreur interne du serveur' });
        }
        if (results.length > 0) {
            console.log(`Utilisateur d√©j√† existant: ${login}`);
            return res.status(409).json({ message: 'Cet utilisateur existe d√©j√†.' });
        }

        // Hasher le mot de passe
        const hashedPassword = await bcrypt.hash(password, 10);
        console.log('Mot de passe hash√© avec succ√®s');

        // G√©n√©rer un token
        const token = jwt.sign({ login, role: role || 'user' }, SECRET_KEY, { expiresIn: '1h' });

        // Enregistrer l'utilisateur en base de donnee
        db.query('INSERT INTO Utilisateur (nom, mot_de_passe, role, token) VALUES (?, ?, ?, ?)',
            [login, hashedPassword, role || 'user', token],
            (err, result) => {
                if (err) {
                    console.error('Erreur lors de l\'insertion de l\'utilisateur :', err);
                    return res.status(500).json({ message: 'Erreur interne du serveur' });
                }
                console.log(`Utilisateur cr√©√© avec succ√®s: ${login} (ID: ${result.insertId})`);
                return res.status(201).json({ message: 'Utilisateur cr√©√© avec succ√®s.', token });
            }
        );
    });
});

// Route de connexion avec logs am√©lior√©s
app.post('/api/login', [
    body('login')
        .isString()
        .isLength({ min: 3 }).withMessage('Le login doit contenir au moins 3 caract√®res.')
        .trim()
        .escape(),
    body('password')
        .isString()
        .isLength({ min: 6 }).withMessage('Le mot de passe doit contenir au moins 6 caract√®res.')
], (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        console.warn(`[${new Date().toISOString()}]  Donn√©es invalides re√ßues`, errors.array());
        return res.status(400).json({ message: 'Donn√©es invalides', errors: errors.array() });
    }

    const { login, password } = req.body;
    console.log(`[${new Date().toISOString()}] üîπ Demande de connexion re√ßue pour: ${login}`);

    db.query('SELECT * FROM Utilisateur WHERE nom = ?', [login], (err, results) => {
        if (err) {
            console.error(`[${new Date().toISOString()}]  Erreur lors de la recherche de l'utilisateur:`, err);
            return res.status(500).json({ message: 'Erreur interne du serveur' });
        }
        if (results.length === 0) {
            console.warn(`[${new Date().toISOString()}] Utilisateur non trouv√©: ${login}`);
            return res.status(401).json({ message: 'Identifiants invalides' });
        }

        const user = results[0];
        console.log(`[${new Date().toISOString()}] Utilisateur trouv√©: ${user.nom}`);

        // V√©rifier le mot de passe
        bcrypt.compare(password, user.mot_de_passe, (err, isMatch) => {
            if (err) {
                console.error(`[${new Date().toISOString()}]  Erreur lors de la comparaison des mots de passe:`, err);
                return res.status(500).json({ message: 'Erreur interne du serveur' });
            }
            if (!isMatch) {
                console.warn(`[${new Date().toISOString()}]  Mot de passe incorrect pour: ${login}`);
                return res.status(401).json({ message: 'Identifiants invalides' });
            }

            // G√©n√©rer un nouveau token
            const nouveauToken = jwt.sign(
                { id_utilisateur: user.id_utilisateur, nom: user.nom, role: user.role },
                SECRET_KEY,
                { expiresIn: '4h' }
            );
            console.log(`[${new Date().toISOString()}]  Connexion r√©ussie, token g√©n√©r√© pour ${login}: ${nouveauToken}`);

            // Mettre √† jour le token en base de donn√©es
            db.query('UPDATE Utilisateur SET token = ? WHERE id_utilisateur = ?', [nouveauToken, user.id_utilisateur], (err) => {
                if (err) {
                    console.error(`[${new Date().toISOString()}]  Erreur lors de la mise √† jour du token en base:`, err);
                    return res.status(500).json({ message: 'Erreur interne du serveur' });
                }

                console.log(`[${new Date().toISOString()}]  Nouveau token enregistr√© en base pour ${login}`);

                res.cookie('token', 'valeur-du-token', {
                    secure: false,    // D√©sactive secure si tu es en HTTP
                    maxAge: 3600000,  // Dur√©e de vie du cookie (1 heure)
                    sameSite: 'Lax',  // Politique SameSite (peut √™tre 'Strict' ou 'None' selon les besoins)
                });                

                // V√©rifier si le cookie est bien d√©fini
                console.log(`[${new Date().toISOString()}] üîπ V√©rification du cookie envoy√©:`, res.getHeader('Set-Cookie'));

                // V√©rifier les en-t√™tes de la r√©ponse
                console.log(`[${new Date().toISOString()}] üîπ Headers de r√©ponse envoy√©s:`, res.getHeaders());

                // Retourner un message de succ√®s
                return res.status(200).json({
                    message: 'Connexion r√©ussie',
                    data: { token: nouveauToken }
                });
            });
        });
    });
});


const verifyToken = (req, res, next) => {
    console.log('--- V√©rification du Token ---');
    
    // Log des cookies re√ßus dans la requ√™te pour v√©rifier leur contenu
    console.log(`[${new Date().toISOString()}] Cookies re√ßus :`, req.cookies);
    
    // R√©cup√©rer le token depuis les cookies ou l'en-t√™te Authorization
    let token = req.cookies.token || req.headers['authorization']?.split(' ')[1];  // R√©cup√©rer le token depuis Authorization

    if (!token) {
        console.warn(`[${new Date().toISOString()}] Acc√®s refus√©: Aucun token trouv√© dans les cookies ou les headers.`);
        return res.status(403).json({ message: 'Token manquant' });
    }

    console.log(`[${new Date().toISOString()}] Token trouv√© dans les cookies ou les headers: ${token.substring(0, 10)}... (raccourci pour s√©curit√©)`);

    // V√©rification du token JWT
    jwt.verify(token, SECRET_KEY, (err, decoded) => {
        if (err) {
            console.error(`[${new Date().toISOString()}] √âchec de la v√©rification du token.`);
            
            // Log de l'erreur sp√©cifique
            console.error(`[${new Date().toISOString()}] D√©tails de l'erreur:`, err);

            if (err.name === 'TokenExpiredError') {
                console.warn(' Token expir√©, demande de renouvellement n√©cessaire.');
                return res.status(401).json({ message: 'Token expir√©' });
            }

            console.error('Erreur lors de la validation du token:', err);
            return res.status(401).json({ message: 'Token invalide' });
        }

        console.log(`[${new Date().toISOString()}] Token valide. Utilisateur: ${decoded.nom}, R√¥le: ${decoded.role}`);
        
        // Ajouter l'utilisateur d√©cod√© √† la requ√™te
        req.user = decoded;

        // Log de l'utilisateur d√©cod√©
        console.log(`[${new Date().toISOString()}] Donn√©es utilisateur extraites du token :`, decoded);

        next();
    });
};


const config = [
    { "name": "de COV","unit": "%", "min": 0, "max": 100, "address": 0 },
    { "name": "d√©bim√®tre","unit": "m3/h", "min": 0, "max": 100, "address": 1 },
    { "name": "d√©bim√®tre","unit": "m3/h", "min": 0, "max": 100, "address": 2 },
    { "name": "d√©bim√®tre","unit": "m3/h", "min": 0, "max": 100, "address": 3 },
    { "name": "d√©bim√®tre","unit": "m3/h", "min": 0, "max": 100, "address": 4 },
    { "name": "de temp√©rature","unit": "¬∞C", "min": -150, "max": 150, "address": 5 },
    { "name": "d'humidit√©","unit": "%", "min": 0, "max": 100, "address": 6 },
    { "name": "de temp√©rature","unit": "¬∞C", "min": -150, "max": 150, "address": 7 },
    { "name": "d'humidit√©","unit": "%", "min": 0, "max": 100, "address": 8 },
    { "name": "de temp√©rature","unit": "¬∞C", "min": -150, "max": 150, "address": 9},
    { "name": "d'humidit√©","unit": "%", "min": 0, "max": 100, "address": 10 },
    { "name": "de temp√©rature","unit": "¬∞C", "min": -150, "max": 150, "address": 11 },
    { "name": "d'humidit√©","unit": "%", "min": 0, "max": 100, "address": 12 },
    { "name": "d'ambiance","unit": "¬∞C", "min": -150, "max": 150, "address": 13 },
    { "name": "de CO2","unit": "ppm", "min": 0, "max": 3000, "address": 14 }
];


// Route pour r√©cup√©rer les vraies donn√©es des 15 capteurs
app.get('/api/capteurs', verifyToken, async (req, res) => {
    console.log('--- Requ√™te re√ßue sur /api/capteurs ---');

    if (!socket.writable) {
        console.error(' Erreur : Connexion Modbus non √©tablie.');
        return res.status(500).json({ message: 'Erreur : connexion Modbus non √©tablie.' });
    }

    try {
        // Lire les registres Modbus
        const totalRegistres = config.length;
        console.log('Envoi de la requ√™te Modbus pour lire les registres');

        const response = await client.readHoldingRegisters(0, totalRegistres);
        const values = response.response._body.values;

        console.log(`Donn√©es Modbus brutes re√ßues : ${JSON.stringify(values)}`);

        const capteursData = config.map((capteurConfig, index) => {
            const value = values[index];
            const valueInRange = Math.max(capteurConfig.min, Math.min(capteurConfig.max, value));

            return {
                capteur_id: capteurConfig.address + 1,
                name: capteurConfig.name,
                unit: capteurConfig.unit,
                value: valueInRange,
                timestamp: new Date().toISOString()
            };
        });

        console.log('üîπ Donn√©es des capteurs trait√©es envoy√©es au client:', JSON.stringify(capteursData));

        return res.json(capteursData);
    } catch (error) {
        console.error('Erreur lors de la lecture Modbus :', error);
        return res.status(500).json({ message: 'Erreur lors de la r√©cup√©ration des donn√©es des capteurs' });
    }
});


// G√©rer la fermeture de connexion proprement
socket.on('error', (err) => {
    console.error('Erreur de connexion Modbus:', err.message);
});

socket.on('close', () => {
    console.log('Connexion Modbus ferm√©e');
});


// Route pour enregistrer les donn√©es des capteurs
app.post('/enregistrer', (req, res) => {
    console.log('Requ√™te re√ßue sur /enregistrer');

    const capteursData = req.body; // Donn√©es envoy√©es en JSON
    console.log('Donn√©es re√ßues:', JSON.stringify(capteursData, null, 2));

    if (!Array.isArray(capteursData) || capteursData.length === 0) {
        console.error(' Aucune donn√©e re√ßue ou format incorrect');
        return res.status(400).json({ error: 'Aucune donn√©e re√ßue ou format incorrect' });
    }

    // Pr√©paration de la requ√™te SQL
    const sql = `INSERT INTO Mesure (id_session, id_capteur, type_mesure, valeur, unite, date_heure, est_archive) VALUES ?`;
    
    // V√©rifier que chaque capteur a bien les bonnes valeurs
    const values = capteursData.map(capteur => [
        capteur.id_session || null, // Assurez-vous que ce champ est nullable en BDD
        capteur.capteur_id, // Correction : capteur_id au lieu de id_capteur
        capteur.name, // Correction : name au lieu de type_mesure
        capteur.value, // Correction : value au lieu de valeur
        capteur.unit, // Correction : unit au lieu de unite
        new Date().toISOString(), // Timestamp actuel
        0 // est_archive mis √† 0 par d√©faut
    ]);

    console.log('Requ√™te SQL pr√©par√©e:', sql);
    console.log('Valeurs √† ins√©rer:', values);

    db.query(sql, [values], (err, result) => {
        if (err) {
            console.error('Erreur lors de l\'insertion des donn√©es :', err);
            return res.status(500).json({ error: 'Erreur lors de l\'enregistrement en BDD' });
        }
        console.log(`${result.affectedRows} enregistrement(s) ajout√©(s)`);
        res.status(200).json({ message: `${result.affectedRows} enregistrement(s) ajout√©(s)` });
    });
});


// ROUTE POUR R√âCUP√âRER LE TOKEN
app.get('/api/get-token/:id', (req, res) => {
    const userId = req.params.id;
    console.log(`üîπ Requ√™te re√ßue pour r√©cup√©rer le token de l'utilisateur ID: ${userId}`);

    const sql = 'SELECT token FROM Utilisateur WHERE id_utilisateur = ?';

    db.query(sql, [userId], (err, result) => {
        if (err) {
            console.error(' Erreur MySQL:', err);
            res.status(500).json({ error: 'Erreur serveur' });
            return;
        }

        if (result.length === 0) {
            console.warn('Token non trouv√© pour l\'utilisateur ID:', userId);
            res.status(404).json({ error: 'Token non trouv√©' });
        } else {
            console.log(` Token trouv√© pour l'utilisateur ID: ${userId}`);
            res.json({ token: result[0].token });
        }
    });
});

app.post('/api/capteur', verifyToken, (req, res) => {
    // V√©rifie que la requ√™te est un tableau
    if (!Array.isArray(req.body) || req.body.length === 0) {
    return res.status(400).json({ message: "Le body doit √™tre un tableau non vide." });
    }
    
    let insertedCount = 0;
    let errors = [];
    
    req.body.forEach((capteur) => {
    const { id_capteur, type, valeur, date_heure } = capteur;
    
    // V√©rifie que tous les champs sont pr√©sents
    if (id_capteur == null || !type || valeur == null || !date_heure) {
      errors.push("Champ manquant pour un capteur.");
      return;
    }
    
    const sql = 'INSERT INTO capteur (id_capteur, type, valeur, date_heure) VALUES (?, ?, ?, ?)';
    db.query(sql, [id_capteur, type, valeur, date_heure], (err, result) => {
      if (err) {
        errors.push(err);
      } else {
        insertedCount++;
      }
    
      // Quand toutes les requ√™tes sont trait√©es
      if (insertedCount + errors.length === req.body.length) {
        if (errors.length > 0) {
          return res.status(500).json({ message: "Erreur lors de l'insertion de certains capteurs.", errors });
        }
        return res.status(201).json({ message: "Tous les capteurs ont √©t√© enregistr√©s avec succ√®s." });
      }
    });
  });
});

app.delete('/api/capteurs', verifyToken, (req, res) => {
    const deleteCapteurs = 'DELETE FROM capteur'; // attention ici : c'est bien ta nouvelle table "capteur"
    
    db.query(deleteCapteurs, (err, result) => {
    if (err) {
    console.error('Erreur lors de la suppression des capteurs :', err);
    return res.status(500).json({ message: 'Erreur lors de la suppression des capteurs.' });
    }
    
    res.status(200).json({ message: 'Tous les capteurs ont √©t√© supprim√©s.' });
  });
});

// Lancer le serveur
app.listen(PORT, () => {
    console.log(`Serveur backend en √©coute sur http://192.168.65.227:${PORT}`);
});
